ğŸ” 1. Hashing
Hashing is a one-way transformation â€” once done, it cannot be undone.

ğŸ“Œ Used for:
Storing passwords securely

Checking if data is tampered

ğŸ§  Think of it like:
Putting a paper into a shredder â€” you can't reconstruct the original paper, but you can compare shred piles to check if they match.

Example:
bash
Copy
Edit
password123 â†’ fbc0e2f8bc9e4ee3c66b4cbdd8a93762
When a user logs in:

You hash their entered password

Compare it to the stored hash

âœ… If matched, the user is authenticated.
âŒ The original password is never saved.

Popular Hashing Algorithms:
SHA-256

bcrypt (best for passwords)

Argon2

ğŸ§™ 2. Encryption
Encryption is a two-way transformation â€” it can be reversed (decrypted) with a key.

ğŸ“Œ Used for:
Protecting data in transit or at rest

Storing sensitive data like access tokens, JWT, etc.

ğŸ§  Think of it like:
Locking your message in a box with a key. Anyone with the key can open it.

Two Types:
Symmetric Encryption â€“ Same key to encrypt and decrypt
(e.g., AES)

Asymmetric Encryption â€“ Public key to encrypt, private key to decrypt
(e.g., RSA)

ğŸ”“ 3. Decryption
Decryption is simply the reverse of encryption. You use the appropriate key to unlock the data and view the original content.

ğŸ’¡ In Authentication Flow:
Task	Uses
Store password	ğŸ” Hashing
Login check	ğŸ” Compare hash
Store token securely	ğŸ”’ Encrypt it
Read token from disk	ğŸ”“ Decrypt it
Secure data transfer	ğŸ”’ HTTPS uses encryption (SSL/TLS)

âš”ï¸ Example Use Case (Login):
User registers:

You hash the password â†’ store in DB.

User logs in:

You hash the entered password â†’ compare with DB hash.

User is authenticated:

You generate an access token, encrypt it (optional), and send it.

User revisits:

You decrypt token (if encrypted), verify, and allow access.












ğŸªª What is JWT?
JWT (JSON Web Token) is a compact, self-contained token that securely transmits information between two parties as a JSON object.

Used for:

User Authentication âœ…

Authorization ğŸ”

Single Sign-On (SSO)

ğŸ§± JWT Structure (3 Parts)
A JWT looks like this:

Copy
Edit
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. 
eyJ1c2VySWQiOiIxMjM0NTYiLCJyb2xlIjoiYWRtaW4ifQ. 
AbCdEfGhIjKlMnOpQrStUvWxYz123456
1ï¸âƒ£ Header
Metadata about the token

json
Copy
Edit
{
  "alg": "HS256",
  "typ": "JWT"
}
2ï¸âƒ£ Payload
The actual data (claims) like user ID, role, etc.

json
Copy
Edit
{
  "userId": "123456",
  "role": "admin",
  "exp": 1718789900
}
3ï¸âƒ£ Signature
Ensures the token wasnâ€™t tampered with.

text
Copy
Edit
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
ğŸ” How JWT Works in Authentication
ğŸ§ª Step-by-Step:
ğŸ“Œ Login
User logs in with correct credentials.

Server creates a JWT with user info + expiry.

Server signs the token with a secret key.

Server sends this token to the client.

ğŸ“Œ Access Protected Routes
Client stores JWT (usually in localStorage or cookies).

On every request to protected API:

JWT is sent in Authorization header like:

http
Copy
Edit
Authorization: Bearer <JWT>
Server verifies the token using the secret.

If valid, server allows access â€” no DB call needed.