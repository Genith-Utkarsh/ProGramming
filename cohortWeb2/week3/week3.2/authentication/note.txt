ğŸ” 1. Hashing
Hashing is a one-way transformation â€” once done, it cannot be undone.

ğŸ“Œ Used for:
Storing passwords securely

Checking if data is tampered

ğŸ§  Think of it like:
Putting a paper into a shredder â€” you can't reconstruct the original paper, but you can compare shred piles to check if they match.

Example:
bash
Copy
Edit
password123 â†’ fbc0e2f8bc9e4ee3c66b4cbdd8a93762
When a user logs in:

You hash their entered password

Compare it to the stored hash

âœ… If matched, the user is authenticated.
âŒ The original password is never saved.

Popular Hashing Algorithms:
SHA-256

bcrypt (best for passwords)

Argon2

ğŸ§™ 2. Encryption
Encryption is a two-way transformation â€” it can be reversed (decrypted) with a key.

ğŸ“Œ Used for:
Protecting data in transit or at rest

Storing sensitive data like access tokens, JWT, etc.

ğŸ§  Think of it like:
Locking your message in a box with a key. Anyone with the key can open it.

Two Types:
Symmetric Encryption â€“ Same key to encrypt and decrypt
(e.g., AES)

Asymmetric Encryption â€“ Public key to encrypt, private key to decrypt
(e.g., RSA)

ğŸ”“ 3. Decryption
Decryption is simply the reverse of encryption. You use the appropriate key to unlock the data and view the original content.

ğŸ’¡ In Authentication Flow:
Task	Uses
Store password	ğŸ” Hashing
Login check	ğŸ” Compare hash
Store token securely	ğŸ”’ Encrypt it
Read token from disk	ğŸ”“ Decrypt it
Secure data transfer	ğŸ”’ HTTPS uses encryption (SSL/TLS)

âš”ï¸ Example Use Case (Login):
User registers:

You hash the password â†’ store in DB.

User logs in:

You hash the entered password â†’ compare with DB hash.

User is authenticated:

You generate an access token, encrypt it (optional), and send it.

User revisits:

You decrypt token (if encrypted), verify, and allow access.