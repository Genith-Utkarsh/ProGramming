🔐 1. Hashing
Hashing is a one-way transformation — once done, it cannot be undone.

📌 Used for:
Storing passwords securely

Checking if data is tampered

🧠 Think of it like:
Putting a paper into a shredder — you can't reconstruct the original paper, but you can compare shred piles to check if they match.

Example:
bash
Copy
Edit
password123 → fbc0e2f8bc9e4ee3c66b4cbdd8a93762
When a user logs in:

You hash their entered password

Compare it to the stored hash

✅ If matched, the user is authenticated.
❌ The original password is never saved.

Popular Hashing Algorithms:
SHA-256

bcrypt (best for passwords)

Argon2

🧙 2. Encryption
Encryption is a two-way transformation — it can be reversed (decrypted) with a key.

📌 Used for:
Protecting data in transit or at rest

Storing sensitive data like access tokens, JWT, etc.

🧠 Think of it like:
Locking your message in a box with a key. Anyone with the key can open it.

Two Types:
Symmetric Encryption – Same key to encrypt and decrypt
(e.g., AES)

Asymmetric Encryption – Public key to encrypt, private key to decrypt
(e.g., RSA)

🔓 3. Decryption
Decryption is simply the reverse of encryption. You use the appropriate key to unlock the data and view the original content.

💡 In Authentication Flow:
Task	Uses
Store password	🔐 Hashing
Login check	🔐 Compare hash
Store token securely	🔒 Encrypt it
Read token from disk	🔓 Decrypt it
Secure data transfer	🔒 HTTPS uses encryption (SSL/TLS)

⚔️ Example Use Case (Login):
User registers:

You hash the password → store in DB.

User logs in:

You hash the entered password → compare with DB hash.

User is authenticated:

You generate an access token, encrypt it (optional), and send it.

User revisits:

You decrypt token (if encrypted), verify, and allow access.